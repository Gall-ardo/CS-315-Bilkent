\documentclass{article}

% Core packages
\usepackage{graphicx}    % For images
\usepackage{titlesec}    % For custom section titles
\usepackage{hyperref}    % For hyperlinks
\usepackage{cite}        % For citations

% Code highlighting
\usepackage{listings}
\usepackage{xcolor}      % For syntax coloring
\usepackage{framed}      % Optional: shaded backgrounds

% Page setup
\usepackage{geometry}
\geometry{margin=1in}

% Spacing
\usepackage{setspace}
\onehalfspacing

% Fonts and encoding
\usepackage[utf8]{inputenc}
\usepackage{amsmath}

% Custom styling
\titleformat{\section}{\large\bfseries}{\thesection}{1em}{}

% Custom colors
\definecolor{background}{rgb}{0.98,0.98,0.98}
\definecolor{keywordcolor}{rgb}{0.0,0.5,0.0}
\definecolor{commentcolor}{rgb}{0.5,0.5,0.5}
\definecolor{stringcolor}{rgb}{0.75,0.0,0.0}
\definecolor{importcolor}{rgb}{0.0,0.0,1.0}
\definecolor{macrocolor}{rgb}{1.0,0.5,0.0}

% Listings default setup
\lstset{
  backgroundcolor=\color{background},
  basicstyle=\ttfamily,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  commentstyle=\color{commentcolor},
  keywordstyle=\color{keywordcolor},
  stringstyle=\color{stringcolor},
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  tabsize=4,
  frame=single,
  rulecolor=\color{black!30},
  framerule=0.5pt,
  numbers=none,
  xleftmargin=8pt,
  framexleftmargin=8pt,
  keywordstyle=[1]\color{keywordcolor},
  keywordstyle=[2]\color{blue},
  keywordstyle=[3]\color{macrocolor}\bfseries
}

% Custom commands
\newcommand{\importcmd}[1]{\textcolor{importcolor}{#1}}
\newcommand{\arda}[1]{\textcolor{blue}{Arda: #1}}

% --- Language Definitions ---

% Rust
\lstdefinelanguage{Rust}{
  morekeywords=[1]{as, break, const, continue, crate, else, enum, extern, false, fn,
    for, if, impl, in, let, loop, match, mod, move, mut, pub, ref, return, self, Self,
    static, struct, super, trait, true, type, unsafe, use, where, while, dyn, abstract, 
    become, box, do, final, macro, override, priv, typeof, unsized, virtual, yield, async, await, try},
  morekeywords=[2]{i8, i16, i32, i64, i128, isize,
                   u8, u16, u32, u64, u128, usize,
                   f32, f64, bool, char, str, Option, Result, String, Vec},
  morekeywords=[3]{println, print, eprintln, dbg, format, panic, assert, todo, unreachable},
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]{"},
  morestring=[b]{'},
}

% Dart
\lstdefinelanguage{Dart}{
  morekeywords={
    abstract, dynamic, this, super, const, final,
    void, var, int, double, bool, String, if, else,
    while, for, in, break, continue, return, class,
    new, null, true, false, import, main, List, Map,
    static, Future, async, await, late
  },
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]",
}

% JavaScript
\lstdefinelanguage{JavaScript}{
  morekeywords=[1]{
    break, case, catch, class, const, continue, debugger, default, delete, do, else,
    export, extends, finally, for, function, if, import, in, instanceof, let, new,
    return, super, switch, this, throw, try, typeof, var, void, while, with, yield,
    await, async
  },
  morekeywords=[2]{console, log, document, window, Math , String, Object},
  keywordstyle=[1]\color{keywordcolor},
  keywordstyle=[2]\color{importcolor}, % <- color for console, log, etc.
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]",
  morestring=[b]',
  morestring=[b]`,
}



% Kotlin
\lstdefinelanguage{Kotlin}{
  morekeywords={
    as, break, class, continue, do, else, false,
    for, fun, if, in, interface, is, null, object,
    package, return, super, this, throw, true, try,
    typealias, typeof, val, var, when, while, by,
    catch, constructor, delegate, dynamic, field,
    file, finally, get, import, init, param, set,
    where
  },
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]",
}

\begin{document}

\include{titlepage}

\section{Operations in each language}



\subsection{Dart}
Dart is an object-oriented programming language with statically typed system and JIT (Just-In-Time) compiler. In Dart there is no such thing as an array; instead there is a class \texttt{List} which can be dynamic or fixed length. \texttt{Lists} are linear data structures that can expand, hold different types of objects, and can be manipulated. 

\begin{itemize}
\item \textbf{What types are legal for subscripts?} \\
 In Dart, array subscripts must be integer. Only integer types can be used after an explicit conversion if they’re not int by default. Other types are illegal to use, and gives compile time error. 
\begin{lstlisting}[language=Dart]
print("1: Legal types for subscripts");
List<int> arr1 = [1, 2, 3, 4, 5];
print(arr1[3]);
// print(arr1[3.0]);    Compile time error
// print(arr1["1"]);    Compile time error
// print(arr1[true]);   Compile time error         
/*double floatIndex = 2.8;
print(arr1[floatIndex]); // Compile time error */
\end{lstlisting}
\textbf{Printed Output:}
\begin{verbatim}
1: Legal types for subscripts
4
\end{verbatim}
    
    
\item \textbf{Are subscripting expressions in element references range checked?} \\
Yes, there is range checking. It is checked at runtime and if the number is out of range an error is thrown. 
\begin{lstlisting}[language=Dart]
print("\n\n2: Range checking in subscripting expressions:");
// print(arr1[10]); // Runtime error 
// print(arr1[-1]); // Runtime error
int index = 4324;
// print(arr1[index]);  // Runtime error 
\end{lstlisting}
\textbf{Printed Output:}
\begin{verbatim}
2: Range checking in subscripting expressions:
\end{verbatim}

\item \textbf{Are ragged multidimensional arrays allowed?} \\
Yes, Dart allows any kind of multidimensional arrays.
\begin{lstlisting}[language=Dart]
print("\n\n3: Ragged multidimensional arrays:");
List<List<int>> ragged = [
[1, 2, 3],
[4, 5],
[6, 7, 8, 9]
];

print(ragged);
print(ragged is List<List<int>>);
print(ragged[0] is List<int>);
\end{lstlisting}
\textbf{Printed Output:}
\begin{verbatim}
3: Ragged multidimensional arrays:
[[1, 2, 3], [4, 5], [6, 7, 8, 9]]
true
true
\end{verbatim}


\item \textbf{Can array objects be initialized?} \\
Yes. When creating an array in Dart, you can give the elements as a list. This list can be heterogeneous. Another way to initialize arrays is to use the \texttt{List.filled} method to give the size of the arrayst and initialize the entire array with the same value. It can also be filled with a function for the specified size with the \texttt{List.generate} method.
\begin{lstlisting}[language=Dart]
print("\n\n4: Initialization of arrays:");
var init1 = [1, "ataturk", 3, true];
print("init1: $init1");
var init2 = List.filled(5, null, growable: false);
print("init2: $init2"); 
var init3 = List<int>.generate(8, (i) => i *  i); 
print("init3: $init3");
var init4 = List.of([5]);
print("init4: $init4");
const init5 = [1, 2, 3, 4, 5];
print("init5: $init5");
\end{lstlisting}
\textbf{Printed Output:}
\begin{verbatim}
4: Initialization of arrays:
init1: [1, ataturk, 3, true]
init2: [null, null, null, null, null]
init3: [0, 1, 4, 9, 16, 25, 36, 49]
init4: [5]
init5: [1, 2, 3, 4, 5]
\end{verbatim}


\item \textbf{Are any kind of slices supported?} \\
Yes. In Dart, a slice can be created by specifying the start index for slicing. You can also specify the end index if desired. It is also possible to take the first N elements, or take after the first N elements. It is also possible to create the desired slice by filtering the array. 
\begin{lstlisting}[language=Dart]
print("\n\n5: Array Slice:");
arr1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
var slice1 = arr1.sublist(2, 5); // (start,end)
print("slice1 : $slice1"); 
var slice2 = arr1.sublist(3); // start
print("slice2 : $slice2");
// First N elements
var slice3 = arr1.take(4).toList();
print("slice3: $slice3");
// skip first n elements
var slice4 = arr1.skip(5).toList();
print("slice4: $slice4");
// Filtering
var slice5 = arr1.where((x) => x > 5).toList();
print("slice5: $slice5");
\end{lstlisting}
\textbf{Printed Output:}
\begin{verbatim}
5: Array Slice:
slice1 : [3, 4, 5]
slice2 : [4, 5, 6, 7, 8, 9, 10]
slice3: [1, 2, 3, 4]
slice4: [6, 7, 8, 9, 10]
slice5: [6, 7, 8, 9, 10]
\end{verbatim}



\item \textbf{Which operators are provided?} \\
\arda{heyyy}
\begin{lstlisting}[language=Dart]
\end{lstlisting}
\textbf{Printed Output:}
\begin{verbatim}
\end{verbatim}   
\end{itemize}
\newpage











\subsection{Go}
 Go is a statically typed and compiled programming language. In go there are two commonly used data structures, slices and maps. Slice is a dynamically sized linear data structure, which provides features like reslicing, appending, etc. Map is an unordered collection of key-value pairs (like hashmap). 
This slice shouldn’t be confused with the one we use in programing languages context, which means “a part of array”. Since slice is dynamic sized, we will use array instead of slice. 
Another important topic to mention is, their decleration or initialization are almost same. The only difference, you have to give the size if you are creating an array (even if you are also initializing). 
\begin{itemize}
\item \textbf{What types are legal for subscripts?} \\
 In Go, array subscripts must be integer. Only integer types can be used after an explicit conversion if they’re not int by default. Other types are illegal to use, and gives compile time error. 
\begin{lstlisting}[language=Go]
fmt.Println("1: Legal types for subscripts: ")
arr1 := [5]int{1,2,3,4,5}
fmt.Println(arr1[3])
var index int64 = 4
fmt.Println(arr1[index])
fmt.Println(arr1[int64(3)]) 
//fmt.Println(arr1[3.3]) // Compile time Error: invalid array index 3.3 (type float64)
fmt.Println(arr1[3.0])
// fmt.Println(arr1["3"]) // Compile time Error: invalid array index "3" (type string)
var index3 float64 = 3.0
fmt.Println(arr1[int(index3)])
// fmt.Println(arr1[index3]) // Compile time Error: (variable of type float64) must be integer
\end{lstlisting}
\textbf{Printed Output:}
\begin{verbatim}
1: Legal types for subscripts: 
4
5
4
4
4
\end{verbatim}


\item \textbf{Are subscripting expressions in element references range checked?} \\	
Yes, there is range checking. For constants it is checked at compile time and for variables it is checked at runtime and if the number is out of range an error is thrown. \begin{lstlisting}[language=Go]
fmt.Println("2: Range checking in Subscripting expressions: ")
// fmt.Println(arr1[9]) // Compile time error for constant index out of range
// fmt.Println(arr1[-2]) // Compile time error for negative index
//var index2 = 9
// fmt.Println(arr1[index2]) // Runtime error: index out of range [9] with length 5
\end{lstlisting}
\textbf{Printed Output:}
\begin{verbatim}
2: Range checking in Subscripting expressions: 
\end{verbatim}


\item \textbf{Are ragged multidimensional arrays allowed?} \\
No. You can achive ragged multidimensinal structures by using \texttt{slices} but you can't use arrays of arrays. If you try to do it, Go fills the places with zero to make it rectangular. If you don't give the size, then it will be slice so again, not a ragged multidimensional array is created.
\begin{lstlisting}[language=GO]
fmt.Println("3: Ragged multidimensional arrays: ")

var multidimensionalArr = [3][2]int{{1,2}, {3,4}, {6,7}}
//var multidimensionalArrOOB = [3][2]int{{1,2}, {3,4}, {6,7,8}} // Compile time error.
fmt.Println(multidimensionalArr)

fmt.Println(reflect.TypeOf(multidimensionalArr).Kind())
fmt.Println(reflect.TypeOf(multidimensionalArr[0]).Kind())

var raggedArr = [3][4]int{{1,2,3,4}, {5,6}, {7,8,9}} // Legal. but not ragged. It fills with 0
fmt.Println(raggedArr)
fmt.Println(reflect.TypeOf(raggedArr).Kind())
fmt.Println(reflect.TypeOf(raggedArr[1]).Kind())

var raggedSlice = [3][]int{{1,2}, {3,4,5}, {6,7,8,9}} // If size is not given, it is array of slices
fmt.Println(raggedSlice)
fmt.Println(reflect.TypeOf(raggedSlice).Kind())
fmt.Println(reflect.TypeOf(raggedSlice[1]).Kind())
\end{lstlisting}
\textbf{Printed Output:}
\begin{verbatim}
3: Ragged multidimensional arrays: 
[[1 2] [3 4] [6 7]]
array
array
[[1 2 3 4] [5 6 0 0] [7 8 9 0]]
array
array
[[1 2] [3 4 5] [6 7 8 9]]
array
slice
\end{verbatim}



\item \textbf{Can array objects be initialized?} \\  
\arda{buna bak}
Yes. Go provides many methods for initializing arrays. While initializing, the size must be specified to create an array, if not then slices created. If size is not specified directly like in \texttt{arr3} then you should put \textbf{...} to assert it is an array. If you don't give that arguement, then it will be a \texttt{slice}.
\begin{lstlisting}[language=Go]
fmt.Println("4: Initialization of arrays: ")
var arr2 = [5]int{1,2,3,4,5}
fmt.Println(reflect.TypeOf(arr2).Kind())
var arr3 = [...]int{1,2,3,4,5}
fmt.Println(reflect.TypeOf(arr3).Kind())
var arr4 = [5]int{} // Initialization with only size
fmt.Println(arr4)
fmt.Println(reflect.TypeOf(arr4).Kind())
var arr5 [5]int = [5]int{1,2,3,4,5}
fmt.Println(reflect.TypeOf(arr5).Kind())
\end{lstlisting}
\textbf{Printed Output:}
\begin{verbatim}
4: Initialization of arrays: 
array
array
[0 0 0 0 0]
array
array
\end{verbatim}



\item \textbf{Are any kind of slices supported?} \\
Yes. Array slicing is supported in go, but the result is a slice, not an array. You can specify beginning or end.
\begin{lstlisting}[language=Go]
fmt.Println("5: Array Slice: ")
slice1 := arr1[1:3] // Slice of array
slice2 := arr1[1:] // Slice of array with capacity
fmt.Println(slice1)
fmt.Println(reflect.TypeOf(slice1).Kind())
fmt.Println(slice2)
fmt.Println(reflect.TypeOf(slice2).Kind())
// slice3 := arr1[1:3:1] //  Compile time error.
\end{lstlisting}
\textbf{Printed Output:}
\begin{verbatim}
5: Array Slice: 
[2 3]
slice
[2 3 4 5]
slice
\end{verbatim}



\arda{heeeeeeeyyyyyyyyyy}
\item \textbf{Which operators are provided?} \\
\begin{lstlisting}[language=Go]
\end{lstlisting}
\textbf{Printed Output:}
\begin{verbatim}
\end{verbatim}
\end{itemize}
\newpage





\subsection{JavaScript}
JavaScript is a dynamically typed, interpreted scripting language. JavaScript uses \texttt{Array} as its primary linear data structure. Although it is called \texttt{Array}, data does not have to be stored side by side in memory, and it can hold heterogeneous elements together. Furthermore, \texttt{Arrays} are dynamic, allowing resizing.

\begin{itemize}
\item \textbf{What types are legal for subscripts?} \\
In JavaScript, subscripts are actually treated as property keys, which are always either strings or symbols. When using bracket notation (arr[index]), JavaScript internally converts the subscript to a string if it's not already a string or a number. If the key is not found, JavaScript will not throw an error, instead it will return \texttt{undefined} and let the program continue.
\begin{lstlisting}[language=JavaScript]
console.log("1: Legal types for subscripts: ");
let arr1 = [1, 2, 3, 4, 5];
console.log(arr1[3]);
let id = 3;
console.log(arr1[id]);
console.log(arr1["1"]);
console.log(arr1[1.0]);
console.log(arr1[[1]]);

console.log(arr1[true]); 
console.log(arr1["ataturk"]);
\end{lstlisting}
\textbf{Printed Output:}
\begin{verbatim}
1: Legal types for subscripts: 
4
4
2
2
2
undefined
undefined
\end{verbatim}


\item \textbf{Are subscripting expressions in element references range checked?} \\
No, JavaScript does not perform range checking for array indices during element access. If an out of bound value is given, JavaScript return \texttt{undefined}.
\begin{lstlisting}[language=JavaScript]
console.log("\n\n2: Range checking in element references:");
console.log(arr1[10]);
console.log(arr1[-1]);
\end{lstlisting}
\textbf{Printed Output:}
\begin{verbatim}
2: Range checking in element references:
undefined
undefined
\end{verbatim}


\item \textbf{Are ragged multidimensional arrays allowed?} \\
Yes, Javascript allows any kind of multidimensional arrays.
\begin{lstlisting}[language=JavaScript]
console.log("\n\n3: Ragged multidimensional arrays:");

let ragged = [
    [1, 2, 3],
    [4, 5],
    [6, 7, 8, 9]
];
console.log(ragged);
console.log(Array.isArray(ragged));
console.log(Array.isArray(ragged[0]));
\end{lstlisting}
\textbf{Printed Output:}
\begin{verbatim}
3: Ragged multidimensional arrays:
[ [ 1, 2, 3 ], [ 4, 5 ], [ 6, 7, 8, 9 ] ]
true
true
\end{verbatim}


\item \textbf{Can array objects be initialized?} \\
JavaScript supports several methods for array initialization, each suited to different use cases. Using square brackets (\texttt{[]}) allows direct literal initialization with mixed types. \texttt{Array(n)} creates an array of length \texttt{n} with uninitialized (empty) slots, while \texttt{Array(a, b, c)} creates an array with those exact elements. \texttt{Array.of(x)} ensures a single-element array containing \texttt{x}, even if \texttt{x} is a number. \texttt{Array.from()} converts iterable or array-like objects into real arrays — for example, converting a string into an array of characters or generating an array using a mapping function. Finally, \texttt{new Uint32Array(n)} creates a typed array of 32-bit unsigned integers with \texttt{n} elements, initialized to zero, offering efficient fixed-type numeric storage.
\arda{bunu gpt yapti degistir.}
\begin{lstlisting}[language=JavaScript]
console.log("\n\n4: Initialization of arrays:");
let init1 = [1, 2, 3, "ataturk", true];
console.log(init1);

let init2 = Array(5); // one parameter -> 5 length with empty items.
console.log(init2);

let init3 = Array(3, 4, 5); // parameters are list 
console.log(init3);

let init4 = Array.of(5); // creates [5]
console.log(init4);

let init5 = Array.from("ataturk"); // from iterable object
console.log(init5);

let init6 = Array.from({ length: 3 }, (_, i) => i + 1); // 
console.log(init6);

let init7 = new Uint32Array(5);
console.log(init7);
\end{lstlisting}
\textbf{Printed Output:}
\begin{verbatim}
4: Initialization of arrays:
[ 1, 2, 3, 'ataturk', true ]
[ <5 empty items> ]
[ 3, 4, 5 ]
[ 5 ]
[
  'a', 't', 'a',
  't', 'u', 'r',
  'k'
]
[ 1, 2, 3 ]
Uint32Array(5) [ 0, 0, 0, 0, 0 ]
\end{verbatim}


\item \textbf{Are any kind of slices supported?} \\
Yes, JavaScript supports array slicing through the \texttt{slice()} method. You can specify a start and optional end index, where the end index is exclusive. Negative indices count from the end of the array. For example, \texttt{slice(1, 3)} returns elements from index 1 to 2, \texttt{slice(3)} returns from index 3 to the end, and \texttt{slice(-3)} returns the last three elements. Combinations like \texttt{slice(3, -2)} and \texttt{slice(-3, -1)} allow for more advanced slicing behavior. Additionally, JavaScript supports functional-style filtering using the \texttt{filter()} method, which can be used to create slices based on conditions rather than indices.

\arda{gpt yapti editle}
\begin{lstlisting}[language=JavaScript]
console.log("\n\n5: Array Slice:");
arr1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
let slice = arr1.slice(1, 3); // (begin, end)
console.log(slice); 
let slice2 = arr1.slice(3); // (begin)
console.log(slice2);
let slice3 = arr1.slice(-3); // (begin)
console.log(slice3); 
let slice4 = arr1.slice(3, -2); // (begin, end)
console.log(slice4);
let slice5 = arr1.slice(-3, -1); // (begin, end)
console.log(slice5);

// using a filter function
let filtered = arr1.filter((item) => item > 5);
console.log("Filtered values (item > 5):", filtered);
\end{lstlisting}
\textbf{Printed Output:}
\begin{verbatim}
5: Array Slice:
[ 2, 3 ]
[
  4, 5,  6, 7,
  8, 9, 10
]
[ 8, 9, 10 ]
[ 4, 5, 6, 7, 8 ]
[ 8, 9 ]
Filtered values (item > 5): [ 6, 7, 8, 9, 10 ]
\end{verbatim}



\item \textbf{Which operators are provided?} \\
\arda{heyyyyyyyy}
\begin{lstlisting}[language=JavaScript]
\end{lstlisting}
\textbf{Printed Output:}
\begin{verbatim}
\end{verbatim}
    
\end{itemize}
\newpage




\subsection{Kotlin}
Kotlin is a statically typed language that runs on the JVM. Kotlin supports \texttt{Arrays}, which are fixed-size data structures. They have to be homogeneous — while you can use a general type like \texttt{Any} to store different kinds of objects, the array still has a single, consistent type. Kotlin also provides dynamic and flexible data structures like \texttt{List} and \texttt{MutableList}, but for the purpose of this assignment, we focus on the fixed-size \texttt{Array} type.


\begin{itemize}
\item \textbf{What types are legal for subscripts?} \\
In Kotlin, array subscripts must be integer. Only integer types can be used after an explicit conversion if they’re not int by default. Other types are illegal to use, and gives compile time error. 
\begin{lstlisting}[language=Kotlin]
println("1. Legal types for subscripts:")
val arr1 = arrayOf(1, 2, 3, 4, 5)
println(arr1[0])
// println(arr1[0.5]) Compile time error: argument type mismatch
// println(arr1["3"]) Compile time error: argument type mismatch
// println(arr1[true])  Compile time error: argument type mismatch
// println(arr1[0..2]) argument type mismatch: actual type is 'IntRange', but 'Int' was expected.
/*
var ind : Long = 3
println(arr1[ind]) // Compile time error: argument type mismatch: actual type is 'Long', but 'Int' was expected.
*/
\end{lstlisting}
\textbf{Printed Output:}
\begin{verbatim}
1. Legal types for subscripts:
1
\end{verbatim}


\item \textbf{Are subscripting expressions in element references range checked?} \\
Yes. In Kotlin, subscripting expressions are range-checked, meaning accessing an index outside the
valid range of an array will raise an error. Kotlin checks that in runtime.
\begin{lstlisting}[language=Kotlin] 
println("\n2. Range checking in subscripting expressions")
// println(arr1[6]) // Runtime error: ArrayIndexOutOfBoundsException
// println(arr1[-1]) // Runtime error: ArrayIndexOutOfBoundsException
val num = 68
// println(arr1[num]) // Runtime error: ArrayIndexOutOfBoundsException.
\end{lstlisting}
\textbf{Printed Output:}
\begin{verbatim}
2. Range checking in subscripting expressions
\end{verbatim}


\item \textbf{Are ragged multidimensional arrays allowed?} \\
Yes, Kotlin allows any kind of multidimensional arrays.
\begin{lstlisting}[language=Kotlin]
println("\n3. Ragged multidimensional arrays")
val raggedArr = arrayOf(arrayOf(1, 2, 3), arrayOf(4, 5), arrayOf(6, 7, 8, 9))
for (i in raggedArr.indices) {
    printArray(raggedArr[i]) 
}
println("Type of raggedArr: ${raggedArr::class.simpleName}") // Array<Array<Int>>
println("Type of raggedArr[0]: ${raggedArr[0]::class.simpleName}") // Array<Int>
println("Type of raggedArr[0][0]: ${raggedArr[0][0]::class.simpleName}") // Int
\end{lstlisting}
\textbf{Printed Output:}
\begin{verbatim}
3. Ragged multidimensional arrays
1 2 3 
4 5 
6 7 8 9 
Type of raggedArr: Array
Type of raggedArr[0]: Array
Type of raggedArr[0][0]: Int
\end{verbatim}



\item \textbf{Can array objects be initialized?} \\
Yes, Kotlin provides several ways to initialize arrays. You can directly provide the elements using the \texttt{arrayOf()} function, use array constructors by specifying the size, or initialize arrays with custom logic using lambda expressions. Kotlin also supports creating arrays with default or null values.
\begin{lstlisting}[language=Kotlin]
println ("\n4. Initialization of arrays")

val arr2 = arrayOf(1, 2, 3, 4, 5, "fdbjlka", 3.14, true) // mix type
printArray(arr2) 

val intArr = IntArray(5) // size 5, 00000
printArray(intArr)

val lambdaArr = Array(5) { it * 2 }
printArray(lambdaArr) // 0 2 4 6 8

val arr4 = arrayOfNulls<Int>(5)
printArray(arr4) 
println(arr4::class.simpleName)

val arr5 = Array<Int?>(5) { null }
printArray(arr5)
\end{lstlisting}
\textbf{Printed Output:}
\begin{verbatim}
4. Initialization of arrays
1 2 3 4 5 fdbjlka 3.14 true 
0 0 0 0 0 
0 2 4 6 8 
null null null null null 
Array
null null null null null
\end{verbatim}

    
    
\item \textbf{Are any kind of slices supported?} \\
Yes. Kotlin offers array slicing. You can specify start and end parameters to determine the range when slicing. You can also specify step parameter for step slicing. Result of these slices will be \texttt{ArrayList}. If you want an array type slice, you can use the \texttt{copyOfRange} method to slice by copying a specific part of the array.
\begin{lstlisting}[language=Kotlin]
println("\n5. Array slices")

val arr6 = arrayOf(1, 2, 3, 4, 5)
val slice = arr6.slice(1..3) // (begin, end) inclusive
println("Kind of slice: ${slice::class.simpleName}") 
printArray(slice)


val slice3 = arr6.slice(0..2 step 2) // step 2
println("Kind of slice: ${slice3::class.simpleName}") 
printArray(slice3)

// To achive array when sliced:
val coppied = arr6.copyOfRange(1, 3) // (begin, end) exclusive
println("Kind of slice: ${coppied::class.simpleName}") 
printArray(coppied)
\end{lstlisting}
\textbf{Printed Output:}
\begin{verbatim}
5. Array slices
Kind of slice: ArrayList
2 3 4 
Kind of slice: ArrayList
1 3 
Kind of slice: Array
2 3
\end{verbatim}




\item \textbf{Which operators are provided?} \\
\arda{heyyyyyyy}
\begin{lstlisting}[language=Kotlin]
println("\n6. Allowed Operations")

\end{lstlisting}
\textbf{Printed Output:}
\begin{verbatim}
\end{verbatim}
\end{itemize}
\newpage










\subsection{PHP}
PHP is a dynamically typed, interpreted scripting language. It offers a single, flexible \texttt{Array} data structure that can behave as both a numerically indexed array and as an associative map. Internally, PHP arrays are implemented as ordered hash tables, allowing mixed key types and dynamic resizing. For this reason, \texttt{array} elements are not stored contiguously in memory like in low-level languages.

\begin{itemize}

\item \textbf{What types are legal for subscripts?} \\
PHP is different from most other languages: It tries to reduce the number of errors by automatically converting many types of subscripts into valid array keys. This includes strings. If a non-integer string is given, it gives an 'undefined character' warning. In this conversion, floating point numbers are converted with the round operation, and will give a 'Deprecated' warning (ie, this is deprecated, but we can still use it without error). Booleans are converted to 0 if false and to 1 if true. Given something that cannot be converted to an integer (like another array), PHP will give a runtime error. \begin{lstlisting}[language=PHP]
echo "1: Legal types for subscripts:\n";
$arr1 = array(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
echo $arr1[3] . "\n";
$index = 3;
echo $arr1[$index] . "\n";
echo $arr1["a"] . "\n"; # Warning: Undefine array key "a"
echo $arr1["3"] . "\n";
echo $arr1[3.8] . "\n"; // Deprecated: Implicit conversion from float 3.8 to int loses precision on line 19
$boolIndex = true;
echo $arr1[$boolIndex] . "\n"; // true => 1
$indArr = array(4);
# echo $arr1[$indArr] . "\n"; // Fatal error: Uncaught TypeError: Cannot access offset of type array on array 
print_r($arr1);
\end{lstlisting}
\textbf{Printed Output:}
\begin{verbatim}
1: Legal types for subscripts:
4
4

Warning: Undefined array key "a" in C:\Users\Msı\CS_315\Homework1\Codes\22202709_Ozongun_
HalilArda.php on line 8

4

Deprecated: Implicit conversion from float 3.8 to int loses precision in C:\Users\Msı\CS_315\
Homework1\Codes\22202709_Ozongun_HalilArda.php on line 10
4
2
Array
(
    [0] => 1
    [1] => 2
    [2] => 3
    [3] => 4
    [4] => 5
    [5] => 6
    [6] => 7
    [7] => 8
    [8] => 9
    [9] => 10
)
\end{verbatim}



\item \textbf{Are subscripting expressions in element references range checked?} \\	
PHP does not perform strict range checking. Accessing an out-of-bounds index does not crash the program, but triggers a warning and returns \texttt{NULL}. Negative indices are also not valid by default.
\begin{lstlisting}[language=PHP]
echo "\n\n2: Range checking in element references:\n";
// echo $arr1[10]; // Warning: Undefined offset
// echo $arr1[-1]; // Warning: Undefined offset
$idx = 9;
// echo $arr1[$idx] . "\n"; // Warning: Undefined offset
\end{lstlisting}
\textbf{Printed Output:}
\begin{verbatim}
2: Range checking in element references:
\end{verbatim}



\item \textbf{Are ragged multidimensional arrays allowed?} \\
Yes, PHP allows any kind of multidimensional arrays.
\begin{lstlisting}[language=PHP]
echo "\n\n 3: Ragged multidimensional arrays: ". "\n";
$ragged = array(
    array(1, 2, 3),
    array(4, 5),
    array(6, 7, 8, 9)
);
print_r($ragged);
\end{lstlisting}
\textbf{Printed Output:}
\begin{verbatim}
3: Ragged multidimensional arrays: 
Array
(
    [0] => Array
        (
            [0] => 1
            [1] => 2
            [2] => 3
        )

    [1] => Array
        (
            [0] => 4
            [1] => 5
        )

    [2] => Array
        (
            [0] => 6
            [1] => 7
            [2] => 8
            [3] => 9
        )

)
\end{verbatim}



\item \textbf{Can array objects be initialized?} \\
PHP supports some ways to initialize arrays: listing all elements, giving as a map, giving key indexes and a value for all, and range of values. Giving it as a map is not intuitive, but it is no different from any other methods, because in all cases PHP has to hold a key impliciltly or explicitly.
\begin{lstlisting}[language=PHP]
echo "\n\n4: Initialization of arrays: \n";
$standartInit = array(1, 3, 2);
$assocInit = array(0 => 1, 2 => 2, 1 => 3);
$shortSyntax = [1, 2, 3, 4, 5];
$defaultInit = array_fill(2, 5, 0); # start from 2. length 5. fill all with 0
$rangeInit = range(7, 5); # 7 to 5
print_r($defaultInit);
print_r($rangeInit);
echo "Arrays are ";
if ($standartInit == $assocInit) {
    echo "equal.\n";
} else {
    echo "not equal.\n";
}
\end{lstlisting}
\textbf{Printed Output:}
\begin{verbatim}
4: Initialization of arrays: 
Array
(
    [2] => 0
    [3] => 0
    [4] => 0
    [5] => 0
    [6] => 0
)
Array
(
    [0] => 7
    [1] => 6
    [2] => 5
)
Arrays are equal.
\end{verbatim}




\item \textbf{Are any kind of slices supported?} \\
In PHP, slicing is supported through a function: array\_slice(). When slicing, you can give start index and length of slice as a parameter. You can use negative index for start in here. There is no step slicing like Python.
\begin{lstlisting}[language=PHP]
echo "\n\n5: Array Slice: \n";

$slice = array_slice($arr1, 1, 2); // (begin, length)
echo "Slice from index 1, length 2:\n";
print_r($slice);

$slice = array_slice($arr1, 1); // (begin)
echo "Slice from index 1 to end:\n";
print_r($slice);

$slice = array_slice($arr1, 0, 2);
echo "Slice from beginning, length 2:\n";
print_r($slice);

$slice = array_slice($arr1, -4, 2); # start from -4th index, length = 2
echo "Slice from -4:\n";
print_r($slice);
\end{lstlisting}
\textbf{Printed Output:}
\begin{verbatim}
5: Array Slice: 
Slice from index 1, length 2:
Array
(
    [0] => 2
    [1] => 3
)
Slice from index 1 to end:
Array
(
    [0] => 2
    [1] => 3
    [2] => 4
    [3] => 5
    [4] => 6
    [5] => 7
    [6] => 8
    [7] => 9
    [8] => 10
)
Slice from beginning, length 2:
Array
(
    [0] => 1
    [1] => 2
)
Slice from -4:
Array
(
    [0] => 7
    [1] => 8
)
\end{verbatim}




\item \textbf{Which operators are provided?} \\
\arda{heeeeeeeyyyyyyy}
PHP supports a variety of array operations, though most are function-based rather than operator-based. Arrays can be sorted, compared using \texttt{==} and \texttt{===}, and concatenated using \texttt{+} or \texttt{array\_merge()}. Element-wise operations are done via \texttt{array\_map()} or loops.
\begin{lstlisting}[language=PHP]
echo "\n\n6: Aloowed Operations: \n";

$a1 = array(1, 2, 3, 4, 5);
$a2 = array(5, 4, 3, 2, 1);
$a3 = array(6, 7, 8, 9, 10);

# sorting
sort($a2);
echo "Sorted Array 2:\n";
print_r($a2);

# equality
if ($a1 == $a2) {
    echo "Arrays are equal.\n";
} else {
    echo "Arrays are not equal.\n";
}

# comparison
if ($a1 < $a3) {
    echo "Array 1 is less than Array 3.\n";
} else {
    echo "Array 1 is not less than Array 3.\n";
}

# Strict comparison: compares values + keys + order
if ($a1 === $a2) {
    echo "Arrays are strictly equal.\n";
} else {
    echo "Arrays are not strictly equal.\n";
}

# concatenation
$a4 = $a1 + $a2;
echo "Concatenation of Array 1 and Array 2:\n";
print_r($a4);
$newMap = array(6 => 7, 8 => 9, 10 => 11);
# concat new map to array 1
$a5 = $a1 + $newMap;
echo "Concatenation of Array 1 and new map:\n";
print_r($a5);

$concated = array_merge($a1, $a2);
echo "Concatenation of Array 1 and Array 2 using array_merge:\n";
print_r($concated);

echo "\nSum: " . array_sum($a1) . "\n";
echo "Count: " . count($a1) . "\n";
echo "Max: " . max($a1) . "\n";
echo "Min: " . min($a1) . "\n";

\end{lstlisting}
\textbf{Printed Output:}
\begin{verbatim}
\end{verbatim}
\end{itemize}
\newpage



\subsection{Python - NumPy}

Python is a dynamically typed, interpreted programming language. Its built-in \texttt{list} is a dynamic and heterogeneous data structure. For this reason, we use the \texttt{ndarray} from the \texttt{NumPy} library in this assignment. \texttt{ndarray} elements have a fixed type, and the \texttt{NumPy} library supports a wide range of operations on them.

\begin{itemize}
\item \textbf{What types are legal for subscripts?} \\
For Numpy ndarrays, array subscripts must be integer. Only integer types can be used after an explicit conversion if they’re not int by default. Other types are illegal to use, and python gives error. 
\begin{lstlisting}[language=Python]
print("1: Legal types for subscripts:")
npArr1 = np.array([1, 2, 3, 4, 5])
print(npArr1[3])
# 64 bit integer
print(npArr1[np.int64(3)])
#print(npArr1[3.2]) # IndexError
#print(npArr1["2"]) # IndexError
#precNum = 3.3
#print(npArr1[precNum]) # IndexError
\end{lstlisting}
\textbf{Printed Output:}
\begin{verbatim}
1: Legal types for subscripts:
4
4
\end{verbatim}


\item \textbf{Are subscripting expressions in element references range checked?} \\
Yes. In Python, subscripting expressions are range-checked, meaning accessing an index outside the valid range of an array will raise an error. Unlike many other languages, Python supports negative indexing, where -1 refers to the last element, -2 to the second last, and so on. However, even negative indices are bounded, you can give indexes from -1 to -(length of array). If you give a smaller value, it will again raise an error. 

\begin{lstlisting}[language=Python]
print("2: Range checking in subscripting expressions:")
#print(npArr1[5]) # IndexError: index out of bounds
print(npArr1[-1])
#print(npArr1[-6]) # IndexError: index out of bounds
\end{lstlisting}
\textbf{Printed Output:}
\begin{verbatim}
2: Range checking in subscripting expressions:
5
\end{verbatim}


\item \textbf{Are ragged multidimensional arrays allowed?} \\
No. It is not allowed to create ragged multidimensional arrays.
\begin{lstlisting}[language=Python]
print("3: Ragged multidimensional arrays:")
multiDimArr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
print(multiDimArr)
#raggedArr = np.array([[1, 2, 3], [4, 5], [7, 8, 9]]) # ValueError: The requested array has an inhomogeneous shape.
\end{lstlisting}
\textbf{Printed Output:}
\begin{verbatim}
3: Ragged multidimensional arrays:
[[1 2 3]
 [4 5 6]
 [7 8 9]]
\end{verbatim}



\item \textbf{Can array objects be initialized?} \\
Yes, Numpy provides many different ways. You can give list of elements, or you can use some methods to fill the array. Below are a few examples:
\begin{lstlisting}[language=Python]
print("4: Initialization of array objects:")
print(np.zeros(5))
print(np.ones(5))
print(np.empty(5))
print(np.full(5, 5))
print(np.arange(5))
print(np.linspace(0, 10, 5))
print(np.random.rand(5))
print(np.random.randn(5))
print(np.random.randint(5))
print(np.random.random(5))
print(np.random.choice(5, 5))
print(np.random.permutation(5))
print(np.random.shuffle(np.arange(5)))
print(np.random.seed(5))
arr1 = np.array([1, 2, 3, 4, 5])
arr2 = np.array([2])*5
print("Array 1:", arr1)
print("Array 2:", arr2, len(arr2))
\end{lstlisting}
\textbf{Printed Output:}
\begin{verbatim}
4: Initialization of array objects:
[0. 0. 0. 0. 0.]
[1. 1. 1. 1. 1.]
[1. 1. 1. 1. 1.]
[5 5 5 5 5]
[0 1 2 3 4]
[ 0.   2.5  5.   7.5 10. ]
[0.81165028 0.80118418 0.62534218 0.12665623 0.566843  ]
[-0.97285996 -0.10634728  0.55805202  1.74687414  0.60430322]
3
[0.8291583  0.27691654 0.44080158 0.30472275 0.50099146]
[4 0 0 3 4]
[4 0 3 2 1]
None
None
Array 1: [1 2 3 4 5]
Array 2: [10] 1
\end{verbatim}

\item \textbf{Are any kind of slices supported?} \\
Yes. Array slicing is supported in Python. Slicing can be done specifying the start and end indices, and different from other languages step slicing is provided(skips elements based on the step). In addition to standard slicing, Python also supports filtering using list comprehensions, allowing you to create arrays considering some conditions.
\begin{lstlisting}[language=Python]
print("5: Array slicing:")
arr3 = arr1[1:4]
print("begin and end given", arr3)
print(type(arr3))
arr3 = arr1[:2]
print("only end given", arr3)
arr3 = arr1[2:]
print("only begin given", arr3)
arr3 = arr1[:]
print("only colon given", arr3)
arr3 = arr1[1:4:2]
print("Step given", arr3)
arr3 = arr1[::-1]
print("Negative step given", arr3)
arr = [1, 2, 3, 4, 5, 6]
filtered = [x for x in arr if x % 3 > 1]
print("Filtered array:", filtered)
\end{lstlisting}
\textbf{Printed Output:}
\begin{verbatim}
5: Array slicing:
begin and end given [2 3 4]
<class 'numpy.ndarray'>
only end given [1 2]
only begin given [3 4 5]
only colon given [1 2 3 4 5]
Step given [2 4]
Negative step given [5 4 3 2 1]
Filtered array: [2, 5]
\end{verbatim}


\item \textbf{Which operators are provided?} \\
\arda{heyyyyyyyyyyy}
\begin{lstlisting}[language=Python]
\end{lstlisting}
\textbf{Printed Output:}
\begin{verbatim}
\end{verbatim}
\end{itemize}
\newpage




\subsection{Rust}
Rust is a statically typed, compiled systems programming language. Rust supports fixed-size \texttt{array} types, which store elements of a single type. Rust also provides \texttt{Vec<T>} type for dynamic collections, but we will stick to the \texttt{arrays}. Also Rust enforces strict memory safety, including bounds checking on array accesses, ensuring robust and predictable behavior.



\begin{itemize}
\item \textbf{What types are legal for subscripts?} \\
    In Rust, only \texttt{usize} can be used as a subscript index. Other types such as \texttt{i32} are not supported. \texttt{usize} is an unsigned integer, and size is determined by architecture (32-bit on 32-bit systems, 64-bit on 64-bit systems).  
\begin{lstlisting}[language=Rust]
println!("1: Legal types for subscripts:");
let arr1 = [1, 2, 3, 4, 5];
println!("{}", arr1[0]);
// println!("{}", arr1["0"]); // Compile time error: error[E0277]: the type `[{integer}]` cannot be indexed by `&str`
//println!("{}", arr1[0.0]); // Compile time error: error[E0277]: the type `[{integer}]` cannot be indexed by `float`
// println!("{}", arr1[0.0f32]); // Compile time error: error[E0277]: the type `[{integer}]` cannot be indexed by `f32`
let mut i = 0;
println!("{}", arr1[i]);
println!("type: of i: {}", type_of(&i));
let i2: u32 = 0;
// println!("{}", arr1[i2]); //Compile time errorL error[E0277]: the type `[{integer}]` cannot be indexed by `u32`
\end{lstlisting}
\textbf{Printed Output:}
\begin{verbatim}
1: Legal types for subscripts:
1
1
type: of i: usize
\end{verbatim}



\item \textbf{Are subscripting expressions in element references range checked?} \\
Yes. Rust performs bounds checking. If the index is a constant, it is checked at compile time and will result in a compile-time error if out of bounds. If it is a variable, it will be checked at runtime.
\begin{lstlisting}[language=Rust]
println!("\n\n2: Range checking in Subscripting expressions: ");
//println!("{}", arr1[9]);  // compile-time denial -> Don't compile.
//println!("{}", arr1[-3]); // Compile time error. Negative integers cannot be used to index on a [{integer},5]
i = 98;
// println!("{}", arr1[i]); // Run-time error.
\end{lstlisting}
\textbf{Printed Output:}
\begin{verbatim}
2: Range checking in Subscripting expressions: 
\end{verbatim}


\item \textbf{Are ragged multidimensional arrays allowed?} \\
No, Rust doesn't allow ragged multidimensional arrays. If you create an array of arrays with different lengths it will result in a compile time error. However, you can create array of vectors (or some other datatypes), which can have different size.  
\begin{lstlisting}[language=Rust]
println!("\n\n3: Ragged multidimensional arrays: ");
let multidimensionalArr = [[1, 2, 3], [4, 5, 6]];
println!("type: of multidimensionalArr: {}", type_of(&multidimensionalArr));

//let raggedArr = [[1, 2, 3], [4, 5]]; // Compile time error.
//println!("type: of raggedArr: {}", type_of(&raggedArr)); 

// array of vectors
let arr_of_vec = [vec![1, 2, 3], vec![4, 5, 6]];
println!("type: of arr_of_vec: {}", type_of(&arr_of_vec));
\end{lstlisting}
\textbf{Printed Output:}
\begin{verbatim}
3: Ragged multidimensional arrays: 
type: of multidimensionalArr: [[i32; 3]; 2]
type: of arr_of_vec: [alloc::vec::Vec<i32>; 2]
\end{verbatim}


\item \textbf{Can array objects be initialized?} \\
Yes. Like most other programing languages, Rust allows arrays to be initialized in different ways. You can list the elements directly (and declare it mutable or not), or you can initalize with same value with length, or you can convert from other data structures (like vectors). Essential point is, the size must be known, either by explicitly specifying it or by providing a fixed number of elements.
\begin{lstlisting}[language=Rust]
println!("\n\n4: Initialization of arrays: ");
let mut arr2 = [5, 6, 7, 8, 9]; // Mutable array
let arr3 = [5, 6, 7, 8, 9]; // Immutable array
let arr4 = [6; 5];
print_array(&arr4);
let arr6: [i32; 5] = [45263, 45263, 45263, 45263, 45263];
print_array(&arr6);
let vec = vec![43, 45, 67, 89, 90]; // Vector
let arr7: [i32; 5] = vec.try_into().unwrap();
print_array(&arr7);
\end{lstlisting}
\textbf{Printed Output:}
\begin{verbatim}
4: Initialization of arrays: 
6  6  6  6  6   
45263  45263  45263  45263  45263   
43  45  67  89  90 
\end{verbatim}



\item \textbf{Are any kind of slices supported?} \\
Yes, Rust supports slicing arrays, but the result is not an array; it is a slice, which is its own type. When slicing, you can use ranges and you don't need to tell begin or end index (you can tell both, or one, or none). You can't do step slicing like in Python.
\begin{lstlisting}[language=Rust]
println!("\n\n5: Array Slices: ");
println!("\n\n5: Array Slices: ");
let slice = &arr1[1..4]; // 1 to 3

println!("slice: {:?}", slice);
println!("type of slice: {}", type_of(&slice));

let slice2 = &arr1[1..];
println!("slice2: {:?}", slice2);
println!("type of slice2: {}", type_of(&slice2));
// step slicing is not supported
\end{lstlisting}
\textbf{Printed Output:}
\begin{verbatim}
5: Array Slices: 
slice: [2, 3, 4]
type of slice: &[i32]
slice2: [2, 3, 4, 5]
type of slice2: &[i32]
\end{verbatim}



\item \textbf{Which operators are provided?} \\
Rust supports several operations on arrays: Sorting, Equality and comparison, Memory equality 
\arda{heeeeeeeeeeeeyyyyyyyyyyyyyyy}
\begin{lstlisting}[language=Rust]
// Sorting.
let mut sortableArr = [5, 2, 3, 4, 1];
println!("Before");
print_array(&sortableArr);
sortableArr.sort();
println!("After sorting:");
print_array(&sortableArr);

// Equality Comparison.
let a1 = [1, 2, 3];
let a2 = [1, 2, 3];
let a3 = [4, 5, 6];

println!("a1 == a2: {}", a1 == a2); // true
println!("a1 == a3: {}", a1 == a3); // false
println!("a1 != a3: {}", a1 != a3); // true

// Comperators.
println!("a1 < a3: {}", a1 < a3); // true
println!("a1 > a3: {}", a1 > a3); // false
println!("a1 <= a3: {}", a1 <= a3); // true
println!("a1 >= a3: {}", a1 >= a3); // false

// memory equality.
println!("a1 == a2: {}", &a1 as *const _ == &a2 as *const _); // false
println!("a1 == a1: {}", &a1 as *const _ == &a1 as *const _); // true
\end{lstlisting}
\textbf{Printed Output:}
\begin{verbatim}

\end{verbatim} 
\end{itemize}
\newpage



\section{Evaluation}

This section evaluates the programming languages in terms of readability and writability of array operations.

\subsection{Dart} 
The array structures in \texttt{Dart} make the language easy to read and write, especially since they are very similar to the structures in classical scripting languages. Operations like subscripting and printing the array are very similar to other languages. 
The use of multidimensional arrays makes the language easier to write in places where such things are required, but it can make it difficult to read. Providing different methods for initializing the array, or slicing the array, increases the flexibility of the language, which in turn increases its writability.  However, the need to distinguish between \texttt{growable} and \texttt{fixed-length} lists make it hard to read.

\subsection{Go}
Creating an array in \texttt{Go} is not very difficult syntactically, but it is almost the same as creating a \texttt{slice}, which I think makes the language difficult to understand. When you're writing, sometimes you don't know what you're creating, and when you're reading, you're not sure which variable you have. Other than that, I think there aren't any other readability and writeability issues with array structures, it's easy to get used to because it's similar to other languages. 

\subsection{JavaScript}
\texttt{JavaScript} offers high flexibility with dynamic arrays. For arrays its syntax is familiar and easy to write. It allows more types for subscripting, thus when writing code it is easier to write compared to other languages. It also allows different types in same array, which makes it more writable.

\subsection{Kotlin}
Creating arrays in \texttt{Kotlin} has low writeability because it is done with constructors, but accessing elements etc. is very similar to other languages, so it is a good language in terms of readability and writeability in general. The fact that we have to specify types when creating arrays has a bad effect on writeability, but increases the reliability of the language.

\subsection{PHP}
\texttt{PHP} allows flexible list behavior via its \texttt{array} structure, which combines characteristics of arrays and hash maps. Although it offers various built-in functions for array manipulation, inconsistencies in naming and parameter order across functions can reduce readability. Dynamic typing can also introduce subtle bugs in list operations.

\subsection{Python (NumPy)} 
\texttt{Python} may be the easiest language to write and read of all these languages. Creating an array is similar to most other languages. You can create arrays in multiple ways and when you access the indexies of the arrays, it performs range checking, but it also allows \texttt{negative indexing} which makes it easy to write. 
Because of the library support, you can create arrays in many ways. And since it allows \texttt{step slicing} or \texttt{list comprehension}, it has a lot of flexibility. It is also an easy language to write because it is similar to English. It also allows much more operations in terms of array operations compared to other languages.

\subsection{Rust}
I think \texttt{Rust} is the most difficult language to write and read among all these languages. Because you can only give \texttt{usize}-type integers for the index when subscripting. Also, the way \texttt{Rust} creates arrays is different from other languages. The syntax for slicing is also different and difficult than other languages. Although the operations it releases are not bad, it is generally a difficult language to syntax. This reduces its readability and writeability, but on the other hand some restrictions increase the reliability of the language. 

\vspace{10pt}
\subsection{Conclusion:}
In my opinion, \textbf{NumPy ndarray} is much better than the other arrays in terms of both readability and writeability. The fact that it allows \texttt{negative indexing} unlike other languages, and especially the operator facilities it provides, definitely makes it easier to write code and puts it ahead. On the other hand, the similarity of arrays and slices in \texttt{Go} reduces the readability of the language, making it less useful for arrays.


\newpage

\section{Learning Strategy}

This section describes the resources I used to do the assignment, and the process of doing the assignment.

\subsection{Materials and Resources}

I gathered information primarily from the official documentation of each language. Below is the list of official documentation pages I consulted for array-related syntax and semantics:

\begin{itemize}
    \item Dart \cite{dartdocs}
    \item Go \cite{godocs}
    \item JavaScript \cite{jsdocs}
    \item Kotlin \cite{kotlindocs}
    \item PHP \cite{phpdocs}
    \item Python \cite{pydocs, numpydocs}
    \item Rust \cite{rustdocs}
\end{itemize}

In addition to the official documentation, I frequently used the following online platforms to understand nuances and resolve specific implementation challenges:

\begin{itemize}
    \item \textbf{W3Schools} \cite{w3schools}: Thanks to the short but complete explanations it provides, it helped me a lot in the first learning of PHP and Javascript languages.
    \item \textbf{GeeksforGeeks} \cite{geeksforgeeks}: For detailed explanations, tutorials, and comparisons of array features across languages.
    \item \textbf{GitHub}: \cite{github} For checking example projects, code snippets, and best practices in idiomatic array usage.
    \item \textbf{Stack Overflow} \cite{stackoverflow}: For clarifications on language-specific behaviors and edge cases, as well as resolving bugs and errors during implementation.
\end{itemize}

\subsection{Experimental Setup and Process}

I installed and configured each language's compiler or interpreter on my local machine using the official distribution sources \cite{dartcomp, gocomp, jscomp, kotlinc, phpcomp, pycomp, rustcomp}. For JavaScript, I used Node.js to execute scripts locally. For all languages, I accessed the documentation in my browser and practiced writing full source files to test each array-related feature as required.

Specifically, for every language, I wrote source files addressing:
\begin{enumerate}
    \item Legal types for subscripts.
    \item Range checking in element references.
    \item Support for ragged multidimensional arrays.
    \item Array initialization methods.
    \item Slicing support.
    \item Provided array operators.
\end{enumerate}

Each file was then compiled and/or interpreted depending on the language. I observed the output, analyzed runtime behavior, and noted differences in compile-time versus runtime error handling. This hands-on experimentation played a critical role in solidifying my understanding.

Several iterations were performed per language to ensure originality and correctness, especially to avoid replicating any existing online examples. I also ensured that my sample programs were complete and self-contained.

\subsection{Personal Communication}
When I was doing the assignment, they asked us to create HTML files for both JavaScript and PHP on the assignment page. Since I couldn't zip them together, I discussed this with Halil Altay Güvenir, the instructor of the course. I also got help from Mehmet Can Şakiroğlu, the teaching assistant of the course, to clarify some questions during the assignment. I would like to thank them both for their guidance.



\newpage
\bibliographystyle{plain}
\bibliography{main}
\end{document}